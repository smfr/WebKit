<!DOCTYPE html><!-- webkit-test-runner [ AsyncOverflowScrollingEnabled=true ] -->
<html>
<head>
<style>

#container {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 400px;
    height: 400px;
    overflow: scroll;
}

@keyframes grow {
    from { scale: 0 1 }
    to { scale: 1 1 }
}

#progress {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 2000px;
    background-color: blue;

    transform-origin: top left;

    animation: grow auto;
    animation-timeline: scroll();
}
        
</style>
</head>
<body>

<div id="container">
    <div id="progress"></div>
</div>

<div>PASS if this does not crash.</div>

<script src="threaded-animations-utils.js"></script>
<script>

(async function () {
    window.testRunner?.dumpAsText();
    window.testRunner?.waitUntilDone();

    // Before animations are applied, the container has visual overflow.
    // Once the animation is applied it no longer does since the content
    // now have `scale: 0` set on it. We wait for the potential acceleration
    // of that animation and its commit to the remote layer tree to make sure
    // we do not crash.
    await animationAcceleration(document.getAnimations()[0]);
    await threadedAnimationsCommit();

    window.testRunner?.notifyDone();
})();

</script>

</body>
</html>
